<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>PIXEL UNIVERSE VR</title>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Consolas', monospace; color: #eee; }
        #ui { position: absolute; inset: 0; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; }
        .panel { pointer-events: all; background: rgba(0,0,0,0.7); padding: 12px; border-radius: 8px; margin: 10px; border: 1px solid #555; box-shadow: 0 0 10px rgba(0,255,255,0.3); }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #00ff00; font-size: 20px; text-shadow: 0 0 5px #00ff00; }
        button { cursor: pointer; background: #007bff; color: white; border: none; padding: 10px 15px; border-radius: 5px; font-weight: bold; transition: background 0.2s; }
        button:hover { background: #0056b3; }
        .hidden { display: none !important; }
        #hp-bar { width: 100%; height: 10px; background: #333; border-radius: 5px; margin-top: 5px; }
        #hp-fill { width: 100%; height: 100%; background: #ff4757; border-radius: 5px; transition: 0.3s; }

        /* í„°ì¹˜ ì¡°ì‘ UI */
        #touch-controls { position:fixed; inset:0; pointer-events:none; z-index:20; display:flex; justify-content:space-between; align-items:flex-end; }
        #joystick-zone { position:relative; width:100px; height:100px; background:rgba(255,255,255,0.15); border-radius:50%; margin:20px; pointer-events:all; }
        #joystick-stick { position:absolute; width:50px; height:50px; background:white; border-radius:50%; opacity:0.6; top:25px; left:25px; transform:translate(0,0); }
        #touch-buttons { display:flex; flex-direction:column; gap:15px; margin:20px; pointer-events:all; }
        .touch-button { width:70px; height:70px; border-radius:50%; background:rgba(0,255,255,0.3); color:white; font-size:1.1em; border:2px solid rgba(0,255,255,0.5); display:flex; justify-content:center; align-items:center; }
        .touch-button.mine { background:rgba(255,71,87,0.4); border:2px solid rgba(255,71,87,0.7); }

        /* VR í™”ë©´ ë¶„í•  (ëª¨ë°”ì¼ì—ì„œë§Œ ì‘ë™) */
        #vr-toggle { position: absolute; top: 10px; right: 10px; pointer-events: all; }
    </style>
</head>
<body>

<div id="login-screen" style="position:fixed; inset:0; background:#111; z-index:100; display:flex; align-items:center; justify-content:center;">
    <div class="panel" style="width:320px; text-align:center; background:#222; border-color:#00ffff;">
        <h1 style="color:#00ffff; text-shadow:0 0 10px #00ffff;">âœ¨ PIXEL UNIVERSE âœ¨</h1>
        <input type="text" id="uid" placeholder="ìœ ì € ID" style="width:90%; padding:12px; margin-bottom:10px; background:#333; border:1px solid #00ffff; color:#eee;">
        <input type="password" id="upw" placeholder="ë¹„ë°€ë²ˆí˜¸" style="width:90%; padding:12px; margin-bottom:20px; background:#333; border:1px solid #00ffff; color:#eee;">
        <button onclick="handleAuth('login')" style="width:48%;">LOGIN</button>
        <button onclick="handleAuth('signup')" style="width:48%; background:#8e44ad;">SIGNUP</button>
    </div>
</div>

<div id="ui" class="hidden">
    <button id="vr-toggle" onclick="toggleVRMode()">ğŸŒ VR ëª¨ë“œ</button>
    <div id="crosshair">+</div>
    
    <div class="panel" style="align-self: flex-start;">
        <div style="font-size: 1.2em; color: #00ffff;">ğŸ’° <span id="money-txt">0</span> G</div>
        <div id="hp-bar"><div id="hp-fill"></div></div>
        <div style="font-size: 0.9em; margin-top: 8px; display:flex; justify-content: space-between;">
            <span>ğŸªµ <span id="inv-WOOD">0</span></span>
            <span>ğŸª¨ <span id="inv-STONE">0</span></span>
            <span>ğŸ’ <span id="inv-DIAMOND">0</span></span>
        </div>
        <div style="margin-top:5px; color:#00ff00; font-size:1em;">âš”ï¸ <span id="weapon-txt">ë§¨ì†</span></div>
    </div>

    <div id="craft-ui" class="panel hidden" style="position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); width:280px; text-align:center; border-color:#f1c40f;">
        <h3 style="margin:0 0 15px 0; color:#f1c40f;">âš’ï¸ ì œì‘ëŒ€</h3>
        <button onclick="craft('IRON_SWORD', 500)" style="width:100%; margin-bottom:8px; background:#e67e22;">ì²  ê²€ (500G)</button>
        <button onclick="craft('DIAMOND_SWORD', 2000)" style="width:100%; margin-bottom:8px; background:#9b59b6;">ë‹¤ì´ì•„ ê²€ (2000G)</button>
        <button onclick="toggleCraft()" style="width:100%; background:#c0392b;">ë‹«ê¸°</button>
    </div>

    <div style="align-self: flex-end; display:flex; gap:10px; margin:10px; pointer-events:all;">
        <button onclick="toggleCraft()" style="background:#e67e22;">âš’ï¸ ì œì‘ëŒ€</button>
    </div>
</div>

<div id="touch-controls">
    <div id="joystick-zone">
        <div id="joystick-stick"></div>
    </div>
    <div id="touch-buttons">
        <div class="touch-button" onclick="jump()">JUMP</div>
        <div class="touch-button mine" onclick="onAction()">MINE</div>
    </div>
</div>

<script>
    const firebaseConfig = {
        apiKey: "AIzaSyC2PE60dAZ-PD440QgploZuoLZckAg6FW0",
        authDomain: "star-edd2c.firebaseapp.com",
        databaseURL: "https://star-edd2c-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "star-edd2c",
        storageBucket: "star-edd2c.firebasestorage.app",
        appId: "1:724074828482:web:90001ae0ccdf0d389ce15b"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    let myId, myModel, scene, camera, renderer, myData = {};
    let chunks = {}, players = {}, blocks = [];
    const keys = {}, CHUNK_SIZE = 14, NOISE_SCALE = 0.08, HEIGHT_SCALE = 4;
    let vY = 0; // ì¤‘ë ¥/ì í”„ ì†ë„
    let isVRMode = false; // VR ëª¨ë“œ í† ê¸€

    const BIOMES = {
        WATER: 0x3498db, SAND: 0xf1c40f, GRASS: 0x2ecc71, STONE: 0x7f8c8d, SNOW: 0xffffff
    };

    // í„°ì¹˜ ì¡°ì´ìŠ¤í‹± ë³€ìˆ˜
    let touchMoveX = 0, touchMoveY = 0;
    let lookTouchStartX = 0, lookTouchStartY = 0;
    let isLooking = false;

    async function handleAuth(type) {
        const id = document.getElementById('uid').value;
        const pw = document.getElementById('upw').value;
        const ref = db.ref('users/' + id);
        const snap = await ref.once('value');
        if(type === 'signup') {
            if(snap.exists()) return alert("ì¤‘ë³µ ì•„ì´ë””!");
            await ref.set({pw, WOOD:0, STONE:0, DIAMOND:0, hp:100, weapon:"ë§¨ì†", money:500, x:0, y:0, z:0, rotY:0, rotX:0});
            alert("ê°€ì… ì„±ê³µ! ë¡œê·¸ì¸í•˜ì„¸ìš”.");
        } else {
            if(snap.exists() && snap.val().pw === pw) { myId = id; start(); }
            else alert("ID ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ ì˜¤ë¥˜.");
        }
    }

    function start() {
        document.getElementById('login-screen').classList.add('hidden');
        document.getElementById('ui').classList.remove('hidden');
        // ëª¨ë°”ì¼ í™˜ê²½ì—ì„œë§Œ í„°ì¹˜ ì»¨íŠ¸ë¡¤ ë³´ì´ë„ë¡
        if (window.innerWidth <= 768) { 
            document.getElementById('touch-controls').style.display = 'flex';
        } else {
            document.getElementById('touch-controls').style.display = 'none';
        }
        init3D();
        sync();
    }

    function init3D() {
        scene = new THREE.Scene();
        // ì‹¤ì œ í•˜ëŠ˜ì²˜ëŸ¼ ë³´ì´ëŠ” ë°°ê²½ (ì¢€ ë” í˜„ì‹¤ê°)
        scene.background = new THREE.CubeTextureLoader()
            .setPath('https://threejs.org/examples/textures/cube/Bridge2/')
            .load(['posx.jpg', 'negx.jpg', 'posy.jpg', 'negy.jpg', 'posz.jpg', 'negz.jpg']);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        renderer.shadowMap.enabled = true; // ê·¸ë¦¼ì í™œì„±í™”
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        myModel = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.2, 0.5), new THREE.MeshStandardMaterial({color: 0x3498db}));
        body.position.y = 1; // ë°œì´ ì§€ë©´ì— ë‹¿ë„ë¡ ì¡°ì •
        body.castShadow = true; // ê·¸ë¦¼ì ë“œë¦¬ìš°ê¸°
        myModel.add(body);
        scene.add(myModel);

        // ì¡°ëª… (íƒœì–‘ + ì£¼ë³€ê´‘)
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
        sunLight.position.set(100, 100, 50);
        sunLight.castShadow = true; // ê·¸ë¦¼ì ìƒì„±
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 500;
        sunLight.shadow.camera.left = -50;
        sunLight.shadow.camera.right = 50;
        sunLight.shadow.camera.top = 50;
        sunLight.shadow.camera.bottom = -50;
        scene.add(sunLight);
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        
        // PC ë§ˆìš°ìŠ¤ ì‹œì  ê³ ì •
        renderer.domElement.addEventListener('click', () => {
            if (window.innerWidth > 768) { // PCì—ì„œë§Œ PointerLock
                renderer.domElement.requestPointerLock();
            }
            document.getElementById('crosshair').style.display = 'block';
        });

        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === renderer.domElement) {
                myModel.rotation.y -= e.movementX * 0.002;
                camera.rotation.x -= e.movementY * 0.002; // ìƒí•˜ ì‹œì 
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x)); // ê³ ê°œ êº¾ì„ ë°©ì§€
            }
        });

        // ëª¨ë°”ì¼ í„°ì¹˜ ì‹œì  ì œì–´ (ì˜¤ë¥¸ìª½ ì ˆë°˜)
        renderer.domElement.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1 && e.touches[0].clientX > window.innerWidth / 2) {
                isLooking = true;
                lookTouchStartX = e.touches[0].clientX;
                lookTouchStartY = e.touches[0].clientY;
            }
        }, {passive: false});

        renderer.domElement.addEventListener('touchmove', (e) => {
            if (isLooking && e.touches.length === 1) {
                e.preventDefault();
                const touch = e.touches[0];
                const deltaX = touch.clientX - lookTouchStartX;
                const deltaY = touch.clientY - lookTouchStartY;

                myModel.rotation.y -= deltaX * 0.005; // ì¢Œìš° íšŒì „
                camera.rotation.x -= deltaY * 0.005; // ìƒí•˜ íšŒì „
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                
                lookTouchStartX = touch.clientX;
                lookTouchStartY = touch.clientY;
            }
        }, {passive: false});

        renderer.domElement.addEventListener('touchend', () => {
            isLooking = false;
        });

        // ë¬¼ íŒŒí‹°í´ ìƒì„±
        createWaterSurface();

        window.addEventListener('mousedown', onAction); // PC ì±„êµ´

        animate();
    }

    function getTerrainHeight(x, z) {
        return Math.floor(Math.sin(x * NOISE_SCALE) * Math.cos(z * NOISE_SCALE) * HEIGHT_SCALE);
    }

    function getBlockColor(h) {
        if (h < -1) return BIOMES.WATER;
        if (h < 0) return BIOMES.SAND;
        if (h < 2) return BIOMES.GRASS;
        if (h < 4) return BIOMES.STONE;
        return BIOMES.SNOW;
    }

    // ë¬¼ í‘œë©´ ìƒì„± (í˜„ì‹¤ê° ì¶”ê°€)
    const waterBlocks = [];
    function createWaterSurface() {
        const waterGeo = new THREE.BoxGeometry(1, 1, 1);
        const waterMat = new THREE.MeshPhysicalMaterial({
            color: BIOMES.WATER,
            transparent: true,
            opacity: 0.8,
            roughness: 0.1,
            metalness: 0.9,
            reflectivity: 0.5,
            clearcoat: 1,
            clearcoatRoughness: 0.1
        });
        // ë¬¼ì€ ë¸”ë¡ì„ ì§ì ‘ ìƒì„±í•˜ëŠ” ëŒ€ì‹ , ë‚®ì€ ì§€í˜•ì„ ì»¤ë²„í•˜ëŠ” ë„“ì€ ë©´ìœ¼ë¡œ ì²˜ë¦¬í•˜ì—¬ í¼í¬ë¨¼ìŠ¤ í–¥ìƒ
        // ì—¬ê¸°ì„œëŠ” ì˜ˆì‹œë¥¼ ìœ„í•´ ë‚®ì€ ì§€í˜•ì—ë§Œ ë¸”ë¡ ìƒì„±
    }

    function updateChunks() {
        const cx = Math.floor(myModel.position.x / CHUNK_SIZE);
        const cz = Math.floor(myModel.position.z / CHUNK_SIZE);
        
        // ì˜¤ë˜ëœ ì²­í¬ ì œê±° (ë©”ëª¨ë¦¬ ìµœì í™”)
        for (const key in chunks) {
            const [chunkX, chunkZ] = key.split(',').map(Number);
            if (Math.abs(chunkX - cx) > 2 || Math.abs(chunkZ - cz) > 2) {
                scene.remove(chunks[key]);
                delete chunks[key];
            }
        }

        for(let x = cx-2; x <= cx+2; x++) { // ë Œë”ë§ ë°˜ê²½ í™•ì¥
            for(let z = cz-2; z <= cz+2; z++) {
                if(!chunks[`${x},${z}`]) {
                    const group = new THREE.Group();
                    for(let lx=0; lx<CHUNK_SIZE; lx++){
                        for(let lz=0; lz<CHUNK_SIZE; lz++){
                            const wx = x*CHUNK_SIZE + lx, wz = z*CHUNK_SIZE + lz;
                            const h = getTerrainHeight(wx, wz);
                            
                            // ë¬¼ ë¸”ë¡ì€ íˆ¬ëª…í•˜ê²Œ ì²˜ë¦¬
                            const isWater = (h < -1);
                            const boxMat = isWater 
                                ? new THREE.MeshPhysicalMaterial({ color: BIOMES.WATER, transparent: true, opacity: 0.6, roughness: 0.1 })
                                : new THREE.MeshStandardMaterial({ color: getBlockColor(h), flatShading: true });

                            const box = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), boxMat);
                            box.position.set(wx, h - 0.5, wz);
                            box.userData = {type: h > 2 ? 'STONE' : 'WOOD'};
                            box.receiveShadow = true; // ê·¸ë¦¼ì ë°›ê¸°
                            box.castShadow = !isWater; // ë¬¼ì€ ê·¸ë¦¼ìë¥¼ ë“œë¦¬ìš°ì§€ ì•ŠìŒ

                            group.add(box);
                            blocks.push(box);
                        }
                    }
                    scene.add(group);
                    chunks[`${x},${z}`] = group;
                }
            }
        }
    }

    function onAction() { // PC ë§ˆìš°ìŠ¤ í´ë¦­ ë° ëª¨ë°”ì¼ MINE ë²„íŠ¼
        const ray = new THREE.Raycaster();
        // PCëŠ” ì¤‘ì•™ ì¡°ì¤€ì„ , ëª¨ë°”ì¼ì€ í™”ë©´ ì¤‘ì•™ (í˜¹ì€ íŠ¹ì • í„°ì¹˜ ì§€ì )
        if (window.innerWidth > 768 || !isLooking) { // PC ë˜ëŠ” í„°ì¹˜ ì‹œì  ì¤‘ì´ ì•„ë‹ ë•Œ
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
        } else { // ëª¨ë°”ì¼ì—ì„œ ì˜¤ë¥¸ìª½ í„°ì¹˜ë¡œ ì‹œì  ëŒë¦¬ëŠ” ì¤‘ì¼ ë•Œ
            // ê°„ë‹¨í•˜ê²Œ ì¹´ë©”ë¼ ì¤‘ì•™ìœ¼ë¡œ ì²˜ë¦¬, ì •êµí•˜ê²Œ í•˜ë ¤ë©´ í„°ì¹˜ ìœ„ì¹˜ ê³„ì‚° í•„ìš”
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
        }

        const hits = ray.intersectObjects(blocks);
        if(hits.length > 0 && hits[0].distance < 6) { // ì±„êµ´ ë°˜ê²½ 6ë¸”ë¡
            const type = hits[0].object.userData.type;
            db.ref('users/'+myId).transaction(d => {
                if(d) { d[type] = (d[type]||0)+1; d.money = (d.money||0)+30; }
                return d;
            });
            hits[0].object.visible = false; // ë¸”ë¡ íŒŒê´´ íš¨ê³¼
        }
    }

    function toggleCraft() { document.getElementById('craft-ui').classList.toggle('hidden'); }
    function craft(item, price) {
        if(myData.money < price) return alert("ëˆ ë¶€ì¡±!");
        db.ref('users/'+myId).update({ money: myData.money - price, weapon: item });
        alert(item + " ì œì‘!");
    }
    function jump() { if(vY === 0) vY = 0.22; }

    function toggleVRMode() {
        isVRMode = !isVRMode;
        if (isVRMode) {
            // ëª¨ë°”ì¼ VR (ì¹´ë“œë³´ë“œ ë“±) í™”ë©´ ë¶„í• 
            renderer.setSize(window.innerWidth / 2, window.innerHeight); // ì™¼ìª½ ëˆˆ
            // ì˜¤ë¥¸ìª½ ëˆˆì„ ìœ„í•œ ë‘ ë²ˆì§¸ ìº”ë²„ìŠ¤ ë˜ëŠ” ë·°í¬íŠ¸ ì„¤ì • í•„ìš”
            alert("VR ëª¨ë“œ (ì‹¤ì œ VR ê¸°ê¸° ì—°ë™ì€ ë³µì¡í•©ë‹ˆë‹¤)");
            // ì´ ë¶€ë¶„ì€ WebXR APIë¥¼ ì‚¬ìš©í•´ì•¼ ì‹¤ì œ VR HMDì™€ ì—°ë™ ê°€ëŠ¥
            // ì˜ˆì‹œë¡œ í™”ë©´ì„ ë¶„í• í•˜ëŠ” ê¸°ë³¸ì ì¸ UIë§Œ êµ¬í˜„
            camera.aspect = (window.innerWidth / 2) / window.innerHeight;
            camera.updateProjectionMatrix();
        } else {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }
    }

    function sync() {
        db.ref('users/'+myId).on('value', s => {
            myData = s.val() || {};
            ['WOOD','STONE','DIAMOND'].forEach(k => document.getElementById('inv-'+k).innerText = myData[k]||0);
            document.getElementById('money-txt').innerText = myData.money || 0;
            document.getElementById('weapon-txt').innerText = myData.weapon || "ë§¨ì†";
            document.getElementById('hp-fill').style.width = (myData.hp || 100) + "%";
            
            // ì´ˆê¸° ìœ„ì¹˜ ë™ê¸°í™”
            if (!myModel.position.x && !myModel.position.z) {
                myModel.position.set(myData.x || 0, myData.y || 0, myData.z || 0);
                myModel.rotation.y = myData.rotY || 0;
                camera.rotation.x = myData.rotX || 0;
            }
        });
        db.ref('live/'+myId).set({x:0, y:0, z:0, rotY:0, rotX:0}); // ì´ˆê¸°í™” ì‹œì 
        db.ref('live').on('value', s => {
            const d = s.val();
            for(let id in d) {
                if(id === myId) continue;
                if(!players[id]) {
                    players[id] = new THREE.Mesh(new THREE.BoxGeometry(0.5,1,0.5), new THREE.MeshStandardMaterial({color:0xe74c3c}));
                    scene.add(players[id]);
                }
                players[id].position.set(d[id].x, d[id].y + 0.5, d[id].z);
                players[id].rotation.y = d[id].rotY;
                // í”Œë ˆì´ì–´ ìƒí•˜ ì‹œì ì€ ëª¨ë¸ì— ì ìš©í•˜ê¸° ì–´ë ¤ìš°ë¯€ë¡œ ìƒëµ
            }
        });
    }

    window.onkeydown = e => { keys[e.code] = true; if(e.code === 'Space') jump(); };
    window.onkeyup = e => keys[e.code] = false;

    // ì¡°ì´ìŠ¤í‹± ì´ë™ ì ìš©
    const joystickZone = document.getElementById('joystick-zone');
    const joystickStick = document.getElementById('joystick-stick');
    let joystickActive = false;
    let joystickDeltaX = 0;
    let joystickDeltaY = 0;

    joystickZone.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = joystickZone.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        joystickActive = true;
        joystickStick.style.transition = 'none';
        joystickStick.style.transform = `translate(${touch.clientX - centerX - joystickStick.offsetWidth/2}px, ${touch.clientY - centerY - joystickStick.offsetHeight/2}px)`;
    }, {passive: false});

    joystickZone.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = joystickZone.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        let dx = touch.clientX - centerX;
        let dy = touch.clientY - centerY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const maxDist = 30; // ìŠ¤í‹±ì´ ì›€ì§ì¼ ìµœëŒ€ ë°˜ê²½

        if (dist > maxDist) {
            dx *= maxDist / dist;
            dy *= maxDist / dist;
        }

        joystickStick.style.transform = `translate(${dx}px, ${dy}px)`;
        joystickDeltaX = dx / maxDist; // -1 to 1
        joystickDeltaY = dy / maxDist; // -1 to 1
    }, {passive: false});

    joystickZone.addEventListener('touchend', () => {
        joystickActive = false;
        joystickStick.style.transition = 'transform 0.2s ease-out';
        joystickStick.style.transform = `translate(0px, 0px)`;
        joystickDeltaX = 0;
        joystickDeltaY = 0;
    });


    function animate() {
        requestAnimationFrame(animate);
        
        const moveSpeed = 0.15;
        const dir = new THREE.Vector3();
        myModel.getWorldDirection(dir); // ìºë¦­í„°ê°€ ë°”ë¼ë³´ëŠ” ë°©í–¥
        const sideDir = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), dir); // ìºë¦­í„°ì˜ ì˜† ë°©í–¥

        // 1. í‚¤ë³´ë“œ ì´ë™
        if(keys['KeyW']) myModel.position.addScaledVector(dir, moveSpeed);
        if(keys['KeyS']) myModel.position.addScaledVector(dir, -moveSpeed);
        if(keys['KeyA']) myModel.position.addScaledVector(sideDir, moveSpeed);
        if(keys['KeyD']) myModel.position.addScaledVector(sideDir, -moveSpeed);

        // 2. í„°ì¹˜ ì¡°ì´ìŠ¤í‹± ì´ë™ (ì •ê·œí™”ëœ ê°’ ì‚¬ìš©)
        if (joystickActive) {
            myModel.position.addScaledVector(dir, -joystickDeltaY * moveSpeed); // ì•/ë’¤
            myModel.position.addScaledVector(sideDir, -joystickDeltaX * moveSpeed); // ì¢Œ/ìš°
        }
        
        // ì¤‘ë ¥ ë° ì§€í˜• ì¶©ëŒ
        const groundY = getTerrainHeight(myModel.position.x, myModel.position.z);
        if(myModel.position.y > groundY + 0.1) vY -= 0.012; // 0.1ì€ ë¸”ë¡ ìœ„ë¡œ ì‚´ì§ ëœ¨ê²Œ í•˜ëŠ” ì—¬ìœ 
        else { 
            myModel.position.y = groundY + 0.1; // ì§€í˜•ë³´ë‹¤ ì‚´ì§ ìœ„ë¡œ
            vY = Math.max(0, vY); // ë•…ì— ë‹¿ìœ¼ë©´ ì í”„ ì†ë„ ì´ˆê¸°í™”
        }
        myModel.position.y += vY;

        updateChunks(); // ì²­í¬ ì—…ë°ì´íŠ¸

        // ìœ„ì¹˜ ë° íšŒì „ DB ì—…ë°ì´íŠ¸
        db.ref('live/'+myId).update({
            x: myModel.position.x,
            y: myModel.position.y,
            z: myModel.position.z,
            rotY: myModel.rotation.y,
            rotX: camera.rotation.x
        });
        
        // ì¹´ë©”ë¼ ì‹œì  (1ì¸ì¹­ì²˜ëŸ¼ ë³´ì´ê¸° ìœ„í•´ ìºë¦­í„° ìœ„ì¹˜ì— ì¹´ë©”ë¼ ë°°ì¹˜)
        // ì¹´ë©”ë¼ë¥¼ ìºë¦­í„° ë¨¸ë¦¬ ìœ„ì¹˜ì— ë†“ê³ , ìºë¦­í„° ëª¨ë¸ì€ íˆ¬ëª…í•˜ê²Œ ì²˜ë¦¬ (í˜¹ì€ ìˆ¨ê¹€)
        camera.position.copy(myModel.position);
        camera.position.y += 1.5; // ìºë¦­í„° ëˆˆë†’ì´ì— ë§ì¶¤
        camera.rotation.y = myModel.rotation.y; // ìºë¦­í„°ì˜ ì¢Œìš° íšŒì „ê³¼ ë™ê¸°í™”

        if (isVRMode) {
            // VR ëª¨ë“œì¼ ë•Œ ë Œë”ë§ ë°©ì‹ ë³€ê²½
            renderer.setViewport(0, 0, window.innerWidth / 2, window.innerHeight); // ì™¼ìª½ ëˆˆ
            renderer.render(scene, camera);
            renderer.setViewport(window.innerWidth / 2, 0, window.innerWidth / 2, window.innerHeight); // ì˜¤ë¥¸ìª½ ëˆˆ
            renderer.render(scene, camera); // ë™ì¼í•œ ì¹´ë©”ë¼ë¡œ ë Œë”ë§ (ê°„ë‹¨í•œ ì¹´ë“œë³´ë“œ í‰ë‚´)
        } else {
            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
            renderer.render(scene, camera);
        }
    }

    // ì°½ í¬ê¸° ë³€ê²½ ì‹œ ë Œë”ëŸ¬ì™€ ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        if (isVRMode) {
            renderer.setSize(window.innerWidth, window.innerHeight); // VR ëª¨ë“œ ì‹œ ì „ì²´ í™”ë©´ ìœ ì§€
        }
    });

    // ëª¨ë°”ì¼ í™˜ê²½ ê°ì§€
    if (window.innerWidth <= 768) {
        document.getElementById('crosshair').style.display = 'none'; // ëª¨ë°”ì¼ì€ í¬ë¡œìŠ¤í—¤ì–´ ëŒ€ì‹  í„°ì¹˜ ë²„íŠ¼
    }
}
</script>
</body>
</html>
